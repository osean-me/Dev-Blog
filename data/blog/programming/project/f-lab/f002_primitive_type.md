---
title: '[F-Lab] Primitive Type'
date: '2021-05-06 00:00:01'
tags: ['F-Lab', 'Primitive Type']
draft: false
summary: 'Primitive Type 에 대해 학습한 내용을 정리 했습니다.'
---

# 기초부터 다지기

오늘은 예습 2일차. 책을 찬찬히 읽어보며 드디어 기본 자료형과 참조 자료형에 대해 공부하게 됐다. 혼공자로 공부할 때는 처음이니까 대충 훑고 가야지! 라는 생각으로, 백선장님 스터디에서는 나도 남들처럼 고급지고 멋지게 정리해봐야지 하는 생각으로 임했다. 결국에 내게 돌아오는 것은 하나도 없었다. byte 는 왜 최대값이 255가 아니라 127인지 이제서야 알게된 셈이다. 늦게라도 알게되었으니 다행이지만 잊지 않기 위해 이해한 내용을 스스로 정리해보려고 한다.

---

# 기본 자료형

기본 자료형에는 총 8 가지의 자료형이 존재한다.

- 논리형
  - boolean
- 정수형
  - byte
  - char
  - short
  - int
  - long
- 소수형
  - float
  - double

각 타입은 범위를 가지게 되는데, 논리형인 boolean 타입은 참 혹은 거짓 중 하나만 의미하기 때문에 1bit의 크기를 가지며 나머지 자료형은 각 크기에 맞는 byte 만큼의 크기를 가진다.

근데 나는 아직도 bit가 뭔지 byte가 뭔지 정확히 자리잡지 못한 것 같다. 그래서 한 번 정리하고 넘어가보려고 한다.

## 데이터의 단위

컴퓨터는 0과 1 밖에 모른다. 즉, 컴퓨터가 하는 모든 행위는 0과 1로만 이루어져 있다. 이러한 컴퓨터의 전기 신호를 단위로 표현한 것이 bit 이며, 0 혹은 1로만 구성되어 있다. 이 때, bit는 아날로그 신호가 아닌 디지털 신호이므로 0과 1 사이에 존재하는 어떤 값도 가질 수 없다.

그렇다면 1bit가 표현 할 수 있는 종류는 몇 개일까? 1bit는 0 혹은 1 중 하나만 가질 수 있으므로 2가지의 경우의 수가 생기며 이는 2 의 값을 가질 수 있다는 의미이다. 더 나아가서 2bit는 몇 개의 경우의 수를 가질 수 있을까? 1bit가 2개의 경우의 수를 가지는데, 이러한 1bit가 두 개 존재하므로 2 X 2의 경우의 수를 가진다. 즉, 2bit는 $2^2$의 값을 가진다. 이를 바탕으로 3bit는 $2^3$(8), 4bit는 $2^4$(16), 5bit는 $2^5$(32), 6bit는 $2^6$(64), 7bit는 $2^7$(128), 8bit는 $2^8$(256)의 값을 가질 수 있다는 의미이다.

## 다시 기본 자료형으로 돌아와서

그러면 Java의 정수형 중 갖는 값이 가장 작은 단위는 byte 단위이며 char 를 제외한 모든 정수형, 소수형 자료형에는 부호가 존재한다. 근데 생각해보면 byte의 최대값은 127이 아니라 255여야 맞는 것 아닐까 라는 의문을 가질 수 있다. 이를 이해하기 위해서는 앞서 언급한 부호와 bit를 연관지어야 한다.

1byte는 8개의 bit의 나열인데, 이때 부호까지 나타내기 위해서는 어딘가에 명시를 해주어야 한다. 이 때, 선배 개발자들은 이러한 8개로 나열한 bit 중 가장 앞에 존재하는 bit가 0일 때는 양수, 1일 때는 음수를 의미하는 것으로 정하자고 했다.

때문에, byte는 0부터 127까지 양수 값을 가질 수 있고 -1부터 -128까지 음수 값을 가질 수 있다. 그렇다면 byte의 최대값을 넘어가거나 최소값에 못미치면 어떻게 될까? 실습으로 알아보자.

### 코드

```java
package day_001;

public class PrimitiveTypes {
	public static void main(String[] args) {
		PrimitiveTypes types = new PrimitiveTypes();
		types.checkByte();
	}

	public void checkByte() {
		byte a = 127;
		a = (byte) (a + 1);
		byte b = -128;
		b = (byte) (b - 1);
		System.out.println("byte 최대값 : " + a);
		System.out.println("byte 최소값 : " + b);
	}
}
```

### 실행 결과

![터미널](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbFgLND%2Fbtq4ejbSMGV%2F59KtX8049t9WEJ6Z6WKfl0%2Fimg.png)

> 분명 지역 변수 a는 byte의 최대값을 넘었고, 지역 변수 b는 byte의 최소값에 못미친다. 그런데 결과로 출력된 값은 a = -128, b = 127이다. 왜 이런 결과가 나왔을까?

지역 변수 a와 b를 2진법으로 표현하면 다음과 같다.

| 지역 변수 | 이진법    |
| --------- | --------- |
| byte a    | 0111 1111 |
| byte b    | 1000 0000 |

2진수로 변환한 지역 변수 a에 1을 더하면 1000 0000 이 되면서 -128의 2진수 값이 된다. 반대로 2진수로 변환한 지역 변수 b에 1을 빼면 0111 1111 이 되면서 127의 2진수 값이 된다.

그렇다면 왜 이렇게 byte를 만들었을까? 이미지 파일을 저장한다고 가정해보자. 만약 저장하고자 하는 이미지 파일이 int로 구성되어 있다면 숫자 하나를 표현하기 위해서 32개의 0과 1을 표시해야 하는 공간이 필요하다. 하지만 byte로 구성되어 있다면 숫자를 표현하기 위한 공간을 4배 절약 할 수 있다. 그래서 데이터를 저장하는 많은 영역에서 byte 값을 조합해 사용한다. 그래야만 적은 공간에 최대한의 내용을 저장 할 수 있기 때문이다.
